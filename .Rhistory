# Remember to set the working directory where the blossum50 matrix is located
setwd("~/Documents/PGB-Workspace/R-Needleman-Wunsch-algorithm")
# Usando blossum50.txt
blossum50 <- read.table("blossum50.txt", header=T, check.names = FALSE)
#Sequences to align
s1 <- "BEAVTY"
s2 <- "BEAST"
#Transformed into vectors
s1v <- c("-", strsplit(s1,"")[[1]])
s2v <- c("-", strsplit(s2,"")[[1]])
# Function to make the scoreMatrix, and make it a globalEnv Data
scoreMatrixFunction <- function(rowSeq,colSeq,refTable){
scoreMatrix <<- matrix(nrow = length(rowSeq), ncol = length(colSeq))
rownames(scoreMatrix) <<- rowSeq
colnames(scoreMatrix) <<- colSeq
for (i in c(1:length(rowSeq))) {
for (j in c(1:length(colSeq))) {
scoreMatrix[i,j] <<- refTable[rowSeq[i], colSeq[j]]
}
}
return(scoreMatrix)
}
scoreMatrixFunction(s1v,s2v,blossum50)
# Function to make the Alignment and Direction Matrix
# We are assuming that gapOpenings and gapExtensions have the same penalty
# By default, gapPenalty will be -1
AlignDirMatrixFunction <- function(rowSeq, colSeq, scoreM, gapPenalty = -1){
# Creation of the matrixes and filling the AS with 0s entirely
AlignmentScore <<- matrix(0, nrow = length(rowSeq), ncol = length(colSeq))
DirectionMatrix <<- matrix(nrow = length(rowSeq), ncol = length(colSeq))
# Filling the row and col names of both matrix
rownames(AlignmentScore) <<- rowSeq
colnames(AlignmentScore) <<- colSeq
rownames(DirectionMatrix) <<- rowSeq
colnames(DirectionMatrix) <<- colSeq
#Filling the first row and the first column with their respective values
DirectionMatrix[1,1] <<- "Done"
for (i in c(2:length(rowSeq))){
AlignmentScore[i,1] <<- AlignmentScore[i-1,1]+gapPenalty
DirectionMatrix[i,1] <<- "U"
}
for (i in c(2:length(colSeq))){
AlignmentScore[1,i] <<- AlignmentScore[1,i-1]+gapPenalty
DirectionMatrix[1,i] <<- "L"
}
# Filling the rest of the matrix, for the DirectionMatrix we are prioritizing
# the diagonal case over the others, so there are 4 possible cases in that matrix
for (i in c(2:length(s1v))){
for (j in c(2:length(s2v))){
# Cases and their respective operations
diag <- AlignmentScore[i-1,j-1]+scoreM[i,j]
up <- AlignmentScore[i-1,j]+gapPenalty
left <- AlignmentScore[i,j-1]+gapPenalty
optimTrace <- which.max(c(diag,up,left))
# Assigning the values depending of the most high value case
# We are prioritizing the cases where Diagonal is the optimal trace
if(optimTrace == 1){
AlignmentScore[i,j] <<- diag
DirectionMatrix[i,j] <<- "D"
}
else if(any(duplicated(c(up, left)))){
if(up==left){
AlignmentScore[i,j] <<- up
DirectionMatrix[i,j] <<- "U/L"
}
}
else if(optimTrace == 2){
AlignmentScore[i,j] <<- up
DirectionMatrix[i,j] <<- "U"
}
else{
AlignmentScore[i,j] <<- left
DirectionMatrix[i,j] <<- "L"
}
}
}
}
AlignDirMatrixFunction(s1v,s2v,scoreMatrix)
# Function to make the TraceBack and getting the most optimal alignments
TraceBackFunction <- function(rowSeq, colSeq, DirectM, AlignM){
# Define the global value of the number of sequences that will be generating
seqs <<- 0
# Define the empty vectors of the alignments
alignRow <- c()
alignCol <- c()
print("initializing TraceBack")
# Defining a function that is a while loop which will be making the trace back depending on the case in the DirectionMatrix
# This function will use these parameters which are the sequences itselves, the directionMatrix, the alignmentMatrix,
# the empty vectors and the coords in the matrixes, which have default values that equal the length of the sequences.
tracingWhile <- function(rowSeq,colSeq,DirectM,AlignM, alignRow, alignCol, i = length(rowSeq) ,j = length(colSeq)){
while (i>1 & j>1) {
# Depending on the case, it will be appending to the empty vectors the values
# that are in the sequences in the determined coordinate
# Case Up
if(DirectM[i,j] == "U"){
alignRow <- append(alignRow, rowSeq[i])
alignCol <- append(alignCol, "-")
i <- i-1
}
# Case Left
else if(DirectM[i,j] == "L"){
alignRow <- append(alignRow, "-")
alignCol <- append(alignCol, colSeq[j])
j <- j-1
}
# Case Diagonal
else if(DirectM[i,j] == "D"){
alignRow <- append(alignRow, rowSeq[i])
alignCol <- append(alignCol, colSeq[j])
i <- i-1
j <- j-1
}
# In the case that Diagonal is not the optimal trace, and the Up and Left
# values are equal, this case will be executed
else{
# This function requires the same parameters as tracing While, but
# does not require default values
CallbackUp <- function(rowSeq,colSeq,DirectM,AlignM,alignRow, alignCol,i,j){
# It begins as it the coord "U/L" that the loop is on were an "Up"
alignRow <- append(alignRow, rowSeq[i])
alignCol <- append(alignCol, "-")
i <- i-1
# It calls the function tracingWhile again but will keep these values, making variations only locally
# This function will call itself when another bifurcation is met
tracingWhile(rowSeq,colSeq,DirectM,AlignM,alignRow, alignCol, i,j)
}
CallbackUp(rowSeq,colSeq,DirectM,AlignM,alignRow, alignCol,i,j)
# When a function CallbackUp ends, it will have showed an alignment with
# The "Up" alternative, so now the "Left" Alternative will begin, being the same
# as the function prior, but changing its beggining
CallbackLeft <- function(rowSeq,colSeq,DirectM,AlignM,alignRow, alignCol,i,j){
# It begins as it the coord "U/L" that the loop is on were an "Left"
alignRow <- append(alignRow, "-")
alignCol <- append(alignCol, colSeq[j])
j <- j-1
tracingWhile(rowSeq,colSeq,DirectM,AlignM,alignRow, alignCol,i,j)
}
CallbackLeft(rowSeq,colSeq,DirectM,AlignM,alignRow, alignCol,i,j)
# This return will avoid the function from going infinite by getting out of the while function
# This will only execute when the very first bifurcation is resolved,
# Since every callback will end in another callbackfunction or ending in any other case of the conditional that will close the loop in that callback,
# Only when the very last is resolved, the execution will return to the first bifurcation made,
# Since the values are still satisfying the loop conditions in the when the first callback took place,
# If we do not end the function here, it will repeat every possible alignment infinitely.
return()
}
}
#After While
# When an alignment is ended, the value seqs will be increased
seqs <<- seqs+1
# This will output the alignment to the console collapsed into two strings
print(paste("Alineamiento nÂº ", seqs, " :"))
print(paste(rev(alignCol), "", collapse = ""))
print(paste(rev(alignRow), "", collapse = ""))
}
tracingWhile(rowSeq,colSeq,DirectM,AlignM,alignRow, alignCol)
# Number of optimal Alignments
print(paste("Numero de alineamientos optimos: ", seqs))
# This will print the Alignment Score
print(paste("Puntuacion de alineamiento: ", AlignM[length(rowSeq), length(colSeq)]))
}
TraceBackFunction(s1v,s2v, DirectionMatrix, AlignmentScore)
View(AlignmentScore)
View(DirectionMatrix)
View(scoreMatrix)
View(AlignmentScore)
